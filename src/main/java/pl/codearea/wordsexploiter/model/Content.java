package pl.codearea.wordsexploiter.model;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import pl.codearea.wordsexploiter.model.entity.Book;
import pl.codearea.wordsexploiter.model.entity.Page;
import pl.codearea.wordsexploiter.model.entity.WordFrequency;
import pl.codearea.wordsexploiter.repository.BookRepository;
import pl.codearea.wordsexploiter.repository.BookSummary;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
public class Content {

    private static final Pattern CONJUNCTION_PATTERN = Pattern.compile("^['a-z]{3,}$");

    @Autowired
    private BookRepository bookRepository;

    public Book findById(Integer id) {
        return bookRepository.findById(id).get();
    }

    public List<BookSummary> getAll() {
        return bookRepository.findAllProjectedBy();
    }

    public void addPDDocument(PDDocument document) {
        final Book book = new Book();
        book.setTitle(document.getDocumentInformation().getTitle());
        bookRepository.save(book);

        CompletableFuture.runAsync(() -> {
            try {
                setBookUniqueContent(book, document);
                setPagesUniqueContent(book, document);
                bookRepository.save(book);
            } finally {
                book.setParsingCompleted(true);
                bookRepository.save(book);
                try {
                    document.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    private void setBookUniqueContent(Book book, PDDocument document) {
        try {
            final Map<String, Integer> uniqueContent = getPDDocumentUniqueContent(document);
            book.setUniqueContent(
                uniqueContent.entrySet().stream()
                    .map(entry -> {
                        WordFrequency wordFrequency = new WordFrequency();
                        wordFrequency.setWord(entry.getKey());
                        wordFrequency.setFrequency(entry.getValue());
                        return wordFrequency;
                    }).collect(Collectors.toList())
            );
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void setPagesUniqueContent(Book book, PDDocument document) {
        try {
            PDFTextStripper textStripper = new PDFTextStripper();
            List<Page> pages = new ArrayList<>();
            for (int pageNumber = 0; pageNumber < document.getNumberOfPages(); ++pageNumber) {
                textStripper.setStartPage(pageNumber);
                textStripper.setEndPage(pageNumber);
                String[] splited = textStripper.getText(document).toLowerCase().split("\\s+");

                Page page = new Page();
                page.setNumber(pageNumber);

                Set<String> uniquePageContent = Arrays.stream(splited)
                    .filter(word -> CONJUNCTION_PATTERN.matcher(word).matches())
                    .collect(Collectors.toSet());
                page.setUniqueContent(uniquePageContent);
                pages.add(page);
            }
            book.setPages(pages);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private Map<String, Integer> getPDDocumentUniqueContent(PDDocument document) throws IOException {
        PDFTextStripper textStripper = new PDFTextStripper();
        int numberOfPages = document.getNumberOfPages();
        textStripper.setStartPage(0);
        textStripper.setEndPage(numberOfPages);
        String[] splited = textStripper.getText(document).toLowerCase().split("\\s+");

        return Arrays.stream(splited)
            .filter(word -> CONJUNCTION_PATTERN.matcher(word).matches())
            .collect(Collectors.toMap(
                word -> word, word -> 1, (n1, n2) -> n1 + 1, TreeMap::new
            ));
    }

    public void delete(Integer id) {
        bookRepository.deleteById(id);
    }
}